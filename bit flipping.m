clc
clear all

%Generate LDPC Matrices

%Let the size of linear code be (n,k) linear code.

%Key with Alice
n = input("The key size");
key_alice = randi([0,1], n, 1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Key for Bob
key_bob = key_alice;
qber = .12;
diff = ceil(qber*n);
modify = randperm(n, diff);
for i = 1:diff
    % Toggle the value at the selected index
    key_bob(modify(i)) = ~key_bob(modify(i));
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Compressing n-bit key to (n-k)-bit syndrome
k = input("Number of parity check equation");

P = randi([0,1],k,n-k);

H = [P' eye(n-k)]; %Parity Checking Matrix


syndrome = mod(H*key_alice,2); %Syndrome sent by Alice
syndrome1 = mod(H*(key_bob),2); %SYndrome generated by Bob
syndrome2 = mod(syndrome+syndrome1,2); %Error syndrome (XOR)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Intitial error guess (within qber limit)

%Key for Bob
init_error = zeros(n,1);
qber = .12;
diff = ceil(qber*n);
modify = randperm(n, diff);
for i = 1:diff
    % Toggle the value at the selected index
    init_error(modify(i)) = ~init_error(modify(i));
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Decoding Using bit-flipping
max_iter=1000;
q_0 = (-1).^init_error *log((1-qber)/qber);
Q_in = zeros(size(H));
Q_out = zeros(size(H));
T_in = zeros(size(H));
T_out = zeros(size(H));
m = sum(H ~= 0, 1); %Degree of each variable node
t = sum(H ~= 0, 2); %Degree of each check node
for iter=1:max_iter
for j = 1:n
    for i = 1:n-k
        sum = 0;
        if i~=m(j)
            sum =  sum + Q_in(i,j);
        end
        if H(i,j) ==1
            Q_out(i,j) = q_0(j)+sum;
        end
    end
end
t_0 = (-1).^syndrome2;
T_in = tanh(Q_out/2);

for i = 1:n-k
    for j = 1:n
        product = 1;
        if j~=t(i) && T_in(i,j)~=0
            product = product*T_in(i,j);
        end
        if H(i,j) ==1
            T_out(i,j) = t_0(i)*product;
        end
    end
end
T_out = 2*atanh(T_out);
Q_in = T_out;

error = zeros(n,1);
for j = 1:n
    sum = 0;
    for i = 1:n-k
        sum =  sum + Q_in(i,j);
    end
    if sum >= 0
        error(j) = 0;   %Flipping the bit accordingly
    else
       error(j) = 1;
    end
   
end
syndrome_est = mod(H * (error),2);
if isequal(syndrome_est, syndrome2)
        disp('LDPC portion of Reconciliation has converged and completes successfully.');        
break;
elseif iter == max_iter
        disp('Maximum number of iterations reached. LDPC Reconciliation incomplete.');
 break;
end
end





